README
======

* Manually merged panasonic-laptop.patch with kernel version
* Compile a debug kernel
* cdpower works (power on/off)
* Compile and install acpi_call module (hacking/acpi_call)
* cdpower hardware switch turns off optical drive
* Add support for ECO (battery charging threshold) mode

What does not work
------------------
* ECO mode is not persistent across reboots. Any help is appreciated. :)


Enabling debug mode
===================

# LILO configuration file
* Compile kernel with CONFIG_DYNAMIC_DEBUG=y and CONFIG_ACPI_DEBUG=y
* CONFIG_KERNEL_VERSION="-dbg"
* Add kernel parameter: addappend = "log_buf_len=16M"
* Mount debugfs
  # mount -t debugfs none /sys/kernel/debug
* Enable debug mode by adding this line:
  # echo -n 'file ec.c +p' | sudo tee /sys/kernel/debug/dynamic_debug/control



Dumping contents of EC
======================

Determine the EC cmd/status & data port:
> cat /proc/ioports | grep EC
0062-0062 : EC data
0066-0066 : EC cmd

Dump contents of the first EC, do:
# od -t x1 /sys/kernel/debug/ec/ec0/io
0000000 08 40 00 00 00 41 2e 00 a6 a0 23 a0 23 80 a0 23
0000020 23 a0 08 08 00 00 00 00 00 00 00 00 00 00 00 00
0000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000220 00 00 00 00 00 00 00 00 00 80 00 80 80 80 80 00
0000240 00 00 00 00 80 80 00 00 a7 26 86 27 80 80 80 32
0000260 80 80 80 80 80 00 80 80 04 00 20 20 00 00 00 00
0000300 13 98 01 07 5a 5a 71 81 2e 00 13 98 00 07 5a 5a
0000320 71 9f 2c 00 00 00 00 00 00 00 00 9f 00 00 00 00
0000340 00 00 00 00 00 9f 00 00 00 00 00 00 00 00 00 00
0000360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000400

The EC signals to the kernel via the acpi interrupt and generates GPE 0x1d


Set debug_layer and debug_level
# echo 0x00080010 > /sys/module/acpi/parameters/debug_layer
# echo 0xa4004606 > /sys/module/acpi/parameters/debug_level
or better
# echo 0x00000006 > /sys/module/acpi/parameters/debug_level

To enable debugging, compile and run enable_debug
> make enable_debug ; ./enable_debug | sh



CDROM power dev file:
/sys/devices/platform/panasonic/cdpower

CDROM on
\_SB_.PCI0.LPCB.EC0_._Q84 [1A]
\_GPE._L0D
\_SB_.PCI0.LPCB.EC0_._QA6

CDROM off
\_SB_.PCI0.LPCB.EC0_._Q84

CDROM eject  \_SB_.PCI0.LPCB.EC0_._QA5 [1A]

Name (SIFR, Package (0x15)
0x01,       // 0x00 - Battery no
0x00,       // 0x01 - LCD type
0x15,       // 0x02 - AC max brightness
0x01,       // 0x03 - AC min brightness
0xFF,       // 0x04 - AC current brightness
0x15,       // 0x05 - DC max brightness
0x01,       // 0x06 - DC min brightness
0x7F,       // 0x07 - DC current brightness
0x00,       // 0x08 - Mute
0x01,       // 0x09 - Reserved
0x00,       // 0x0a - ECO mode. 0x83 on, 0x03 off
0x00,       // 0x0b - Sticky key, 0xc0
0x0B,       // 0x0c - 0xb
0xFF,       // 0x0d - Current brightness
0x00,       // 0x0e
0x00,       // 0x0f
0x00,       // 0x10
0x00,       // 0x11
0x00,       // 0x12 - 0x3
Ones,       // 0x13 - 0x06 discharging. 0x13 charging. Used by Win 2006?
0x05        // 0x14

In the DSDT, SINF contains 15 entries. They correspond to the SINF_BITS array.



Dumping DSDT table
==================
# acpidump > acpidata.dat
# acpixtract -sSSDT acpidata.dat
# acpixtract -sDSDT acpidata.dat
# iasl -d dsdt.dat ssdt*.dat


To insert DSDT into ACPI emulator
=================================
> acpiexec dsdt.aml

- execute 


To list acpi kernel function calls
==================================
> cat /proc/kallsyms | grep acpi


To test acpi_calls
==================
# cd acpi_call
# make ; make modules
# modprobe acpi_call

e.g. to turn on/off DVDROM power
# echo "\_SB_.CDON" > /proc/acpi/call
# echo "\_SB_.CDDR" > /proc/acpi/call
# echo "\_SB_.CDDI" > /proc/acpi/call

Drive ON/OFF switch send notify signal: 
Dispatching Notify on [OPTD] (Device) Value 0x03 (Eject Request) Node ffff88003c42e988


\_SB.ECWR Args0 Args1 (EC WRite?)
=================================

Args0 = 0x01: Controls power switch LED
Args1 = 0x00  -> off
        0x01  -> on
        0x02  -> on
        0x03  -> flash as suspend
        0x04  -> off

Args0 = 0x0A: Power off instantly
Args1 = 0x0X

Args0 = 0x15: Control ECO mode. NOTE: The state doesn't survive across power cycle and I haven't figured out how to save
      	      	      	  	      the state to EC or BATT at this stage.
Args1 = 0x00  -> ECO mode off
        0x80  -> ECO mode on

Args0 = 0x0B: Control screen brightness
Args1 = 0x00 - 0xFF: Min - max, Probably at an interval of 8.

Args0 = 0x3A: Control RFKill
Args1 = 0x00  -> RFKill on
        0x04  -> RFKill off


Save ECWR to 
\_SB.PCI0.LPCB.EC0.EC8B
0x5D
0x9F


\_PTS
=====
0x03
0x04    LAN
0x05    unknown


\_SB.PCI0.LPCB.EC0._Q0A
\_SB.PCI0.LPCB.EC0._Q0B
\_SB.PCI0.LPCB.EC0._Q0C
\_SB.PCI0.LPCB.EC0._Q0D
\_SB.PCI0.LPCB.EC0._Q0E
\_SB.PCI0.LPCB.EC0._Q0F
\_SB.PCI0.LPCB.EC0._Q10
\_SB.PCI0.LPCB.EC0._Q11
\_SB.PCI0.LPCB.EC0._Q12
\_SB.PCI0.LPCB.EC0._Q13
\_SB.PCI0.LPCB.EC0._Q14
\_SB.PCI0.LPCB.EC0._Q15
\_SB.PCI0.LPCB.EC0._Q23
\_SB.PCI0.LPCB.EC0._Q70
\_SB.PCI0.LPCB.EC0._Q71
\_SB.PCI0.LPCB.EC0._Q72
\_SB.PCI0.LPCB.EC0._Q73
\_SB.PCI0.LPCB.EC0._Q74
\_SB.PCI0.LPCB.EC0._Q75
\_SB.PCI0.LPCB.EC0._Q76
\_SB.PCI0.LPCB.EC0._Q77
\_SB.PCI0.LPCB.EC0._Q78
\_SB.PCI0.LPCB.EC0._Q79
\_SB.PCI0.LPCB.EC0._Q80
\_SB.PCI0.LPCB.EC0._Q81
\_SB.PCI0.LPCB.EC0._Q82
\_SB.PCI0.LPCB.EC0._Q83
\_SB.PCI0.LPCB.EC0._Q84
\_SB.PCI0.LPCB.EC0._Q7A
\_SB.PCI0.LPCB.EC0._Q7B
\_SB.PCI0.LPCB.EC0._QA0
\_SB.PCI0.LPCB.EC0._QA3
\_SB.PCI0.LPCB.EC0._QA5
\_SB.PCI0.LPCB.EC0._QA7
\_SB.PCI0.LPCB.EC0._QA8
\_SB.PCI0.LPCB.EC0._Q5C
\_SB.PCI0.LPCB.EC0._Q9F
\_SB.PCI0.LPCB.EC0.INI2
\_SB.PCI0.LPCB.EC0.EC8D  0x22262e0 01 Args 1 Len 00A6 Aml 0x2210cbd
\_SB.PCI0.LPCB.EC0.EC03  0x22263c0 01 Args 2 Len 009E Aml 0x2210d6b
\_SB.PCI0.LPCB.EC0.ECGE




Results of \_SB_.ECPF
=====================

\_SB.ECPF 0x0100 0 0    // call EC01, return power status. 0x0 = online, 0x1 = offline
\_SB.ECPF 0x0101 0x00 0  -> EC02 Arg1          Unknown
\_SB.ECPF 0x0110 Arg1 Arg2 -> EC03 Arg1 Arg2            // called by _BST
[0x1, 0x1090, 0x7436, 0x2a36]                           // discharging
[0x2, 0x3a48, 0x71d4, 0x2b6e]                           // charging


\_SB.PCI0.LPCB.EC0.EC03 Args 2
0x00 0x00 -> EC86 0x6A          // charging = 0x0, discharging = 0x1
0x00 0x01 -> EC8D 0x6C          // present rate
0x00 0x02 -> 0x100a             // remaining capacity
0x00 0x03 ->             	// present voltage

\_SB.ECPF 0x0111 Arg1 Arg2 -> EC04 Arg1 Arg2            // Return BATA buffer. Called by _BST & _BTP
\_SB.ECPF 0x0112 Arg1 Arg2 -> EC05 Arg1 Arg2            // called by _BTP
\_SB.ECPF 0x0205 Arg1 -> EC0B Arg1
\_SB.ECPF 0x0206 Arg1 -> EC0C Arg1
\_SB.ECPF 0x0207 Arg1 -> EC0D Arg1                      // Lid
\_SB.ECPF 0x0208 Arg1 -> EC0E Arg1                      // hotkeys
\_SB.ECPF 0x0209 Arg1 -> EC0F Arg1                      // hotkeys
\_SB.ECPF 0x020A Arg1 Arg2 -> EC10 Arg1 Arg2
\_SB.ECPF 0x0214 Arg1 Arg2 -> EC19 Arg1 Arg2

\_SB_.ECPF 0x0216

\_SB_.ECPF 0x0101 0 0  -> EC02 Arg1          Unknown
  
\_SB_.ECPF 0x0110 0 0  -> EC03 Arg1 Arg2


  -> EC8B
  Prepare to sleep related


\_SB_.PCI0.LPCB.EC0_.EC85 0x60 

\_SB_.PCI0.LPCB.EC0_.EC86 0x28 

EC03 calls \_SB_.PCI0.LPCB.EC0_.EC86 0x6A

EC01 calls \_SB_.PCI0.LPCB.EC0_.EC86 0x08

EC8D 0x6C
EC8D 0x6E
EC8D 0x70


Battery info query
==================
\_SB.ECPF 0x0111 Arg1 Arg2 -> EC04 Arg1 Arg2      // called by _BST & _BTP
\_SB.ECPF 0x0112 Arg1 Arg2 -> EC05 Arg1 Arg2      // called by _BTP
\_SB.PCI0.LPCB.EC0.EC04, Arg0, Arg1 (BIFR index)
\_SD.PCI0.LPCB.EC0.EC04 0x00 0x02 -> EC85 (0x64)  // last full capacity


\_SB.PCI0.LPCB.EC0._REG Args 2
\_SB.PCI0.LPCB.EC0.HCNV Args 1
\_SB.PCI0.LPCB.EC0.EC8D
0x6C = 0x0
0x6E = 0x103e
0x70 = 0x2e80


\_SB.PCI0.LPCB.EC0.EC0B Args 1
\_SB.PCI0.LPCB.EC0.EC02 Args 1          // calls EC86
\_SB.PCI0.LPCB.EC0.EC05 Args 2          // calls EC82 
\_SB.PCI0.LPCB.EC0.EC0C Args 1          // set sleep timer
\_SB.PCI0.LPCB.EC0.EC0D Args 1          // call EC8B
\_SB.PCI0.LPCB.EC0.EC0E Args 1          //  ECO
\_SB.PCI0.LPCB.EC0.EC0F (0x01|0x00)     // call EC83 0x17 (0x01|0x00)
\_SB.PCI0.LPCB.EC0.EC10 Args 2
\_SB.PCI0.LPCB.EC0.EC20 Args 2
\_SB.PCI0.LPCB.EC0.EC19 Args 2
\_SB.PCI0.LPCB.EC0.EC1A Args 2
\_SB.PCI0.LPCB.EC0.EC82 0x41 0x00 or 0xF0 Arg1
\_SB.PCI0.LPCB.EC0.EC83 Args 2
0x0B Arg1
0x17 Arg1

\_SB.PCI0.LPCB.EC0.EC89 Args 2                          // calls EC87
\_SB.PCI0.LPCB.EC0.EC84 (0x8C 0x0C | 0x9C 0x08)            // return EBUF


\_SB.PCI0.LPCB.EC0.EC85 (0x60|62|64|68|72|74|76|78|9A)  // query BIFR
calls EC86 (Args0 + 1), i.e. EC86 0x65


\_SB.PCI0.LPCB.EC0.EC86 0x64 -> 0x17, EC86 0x65 -> 0xb6         // ECO off
\_SB.PCI0.LPCB.EC0.EC86 0x64 -> 0x4d, EC86 0x65 -> 0x14         // ECO on


\_SB.PCI0.LPCB.EC0.EC8F Args 2
\_SB.PCI0.LPCB.EC0.EC87 Args 2                          // called by EC89
EC87 0x04 0xC5 = 0x5a
EC87 0x04 0xC6 = 0x71
EC87 0x04 0xC8 = 0x2d

\_SB.PCI0.LPCB.EC0.EC8B 0x43 (0x98|0x81)        // called by EC0D
EC8B 0x5D 0x9F
EC8B 0x5D 0x81

\_SB.PCI0.LPCB.EC0.EC8A Args 3
0x00 0x23 ((EC87 0x00 0x23) & 0xFD)
0x01 0x9C 0xFF
0x13
0x14

\_SB.PCI0.LPCB.EC0.EC8E 0x35
\_SB.PCI0.LPCB.EC0.EC1E Args 2
\_SB.PCI0.LPCB.EC0.EC88 Args 1
\_SB.PCI0.LPCB.EC0.EC8C Args 2                          // returns BUF





ACPI event on Let's Note CF-W5 for kernel 4.4.38 
================================================

video/brightnessup BRTUP 00000086 00000000 K	// F1 pressed
video/brightnessup BRTUP 00000086 00000000      // F1 released
video/brightnessdown BRTDN 00000087 00000000	// F2
video/brightnessdown BRTDN 00000087 00000000 K
button/mute MUTE 00000080 00000000 K		// F3
button/mute MUTE 00000080 00000000 K
button/volumedown VOLDN 00000080 00000000 K	// F5
button/volumedown VOLDN 00000080 00000000 K
button/volumeup VOLUP 00000080 00000000 K	// F6
button/volumeup VOLUP 00000080 00000000 K
button/sleep SBTN 00000080 00000000 K		// F7
button/battery BAT 00000080 00000000 K		// F9
button/suspend SUSP 00000080 00000000 K		// F10
button/power PBTN 00000080 00000000   		// power button pressed
button/power LNXPWRBN:00 00000080 00000002	// power button released

ac_adapter ACPI0003:00 00000080 00000001        // connect AC
ac_adapter ACPI0003:00 00000080 00000000        // disconnect AC


[0x1, 0x0, 0x15, 0x1, 0x15, 0x15, 0x1, 0x9, 0x0, 0x1, 0x3, 0xc0, 0xb, 0xbf, 0x0, 0x0, 0x0, 0x0, 0x3, 0x6, 0x5]  // ECO off, not charging
[0x1, 0x0, 0x15, 0x1, 0x15, 0x15, 0x1, 0x9, 0x3, 0x1, 0x83, 0xc0, 0xb, 0xff, 0x0, 0x0, 0x0, 0x0, 0x3, 0x6, 0x5] // CDROM on, ECO on, not charging
[0x1, 0x0, 0x15, 0x1, 0x15, 0x15, 0x1, 0x9, 0x3, 0x1, 0x83, 0xc0, 0xb, 0xff, 0x0, 0x0, 0x0, 0x0, 0x3, 0x13, 0x5] //

Test if Windows changes current AC/DC brightness
[0x1, 0x0, 0x15, 0x1, 0x12, 0x15, 0x1, 0x9, 0x0, 0x1, 0x83, 0xc0, 0xb, 0x20, 0x0, 0x0, 0x0, 0x0, 0x3, 0x13, 0x5]



SSET 0x80 0x01 
SINF [0x0A]  // ECO state: 0x83 = on, 0x03 = off

To return ECO mode:
ECPF (0x215, 0x00, 0x00)  ->  EC1C  -> EC86 (0x15)  -> EC87 (0x13, 0x95)

ECPF (0x0208, 0x0|0x1, 0x0) -> EC0E (0x0|0x1)


To set Sticky key:
ECPF (0x218, 0 0) -> (result << 0x6 | 0x80)



PSRV (0x99, (Local0 + (Local1 << 0x10)), 0x00, 0x00, 0x00)  // called by ECWR
PSRV (0x92, 0x05, 0x01, Local0, 0x01)
PSRV (0x94, 0x01, 0x01, 0x01, 0x03)
PSRV (0xC9, 0x02, 0x01, Local0, 0x00)
PSRV (0x96, 0x19003434, 0x01, Local1, 0x03)  // change brightness
PSRV (0x96, 0x19003434, 0x01, Local1, 0x01)  // mute
PSRV (0x9C, 0x00, 0x00, 0x00, 0x00)               // RTMP
PSRV (0xC9, 0x04, 0x00, 0x00, 0x00)               // RTMP
        \_SB.PSRV (0x92, 0x03, 0x01, \CKOS (), 0x00)
        If (!\_SB.PSRV (0xDB, Zero, Zero, Zero, One))
            \_SB.PSRV (0xC9, 0x05, 0x00, 0x00, 0x00)
            Local0 = \_SB.PSRV (0x93, 0x01, 0x00, 0x00, 0x03)
PSRV (0xC9, 0x03, One, One, 0x00)                       // \_SB. ADAC
PSRV (0xDB, Zero, Zero, Zero, One))                     // MCHD
PSRV (0xC9, 0x04, 0x00, 0x00, 0x00)                   
                    \_SB.PSRV (0xC9, 0x03, One, One, 0x00)
                \_SB.PSRV (0x92, 0x03, 0x01, \CKOS (), 0x00)
                    \_SB.PSRV (0xB9, 0x20, 0x01, STDS, 0x00)
                        Local0 = \_SB.PSRV (0xB9, 0x01, 0x00, 0x00, 0x03)
                        Local0 = \_SB.PSRV (0xB9, 0x01, 0x00, 0x00, 0x03)
PSRV (0xCA, 0x00, 0x00, 0x00, 0x03)               // TPM status
                                \_SB.PSRV (0xC9, 0x02, 0x01, PWRS, 0x00)
                        Local0 = \_SB.PSRV (0xD6, 0x00, 0x00, 0x00, 0x01)
                            Local0 = \_SB.PSRV (0xC3, Local0, 0x00, 0x00, 0x03)
                        \_SB.PSRV (0xC9, 0x02, 0x01, PWRS, 0x00)
                        \_SB.PSRV (0xD5, 0x00, 0x00, 0x00, 0x00)
                            Local0 = \_SB.PSRV (0xC3, Local0, 0x00, 0x00, 0x03)
                            Local0 = \_SB.PSRV (0xC3, Local0, 0x00, 0x00, 0x03)
                            Local0 = \_SB.PSRV (0xC3, Local0, 0x00, 0x00, 0x03)
                        Return (\_SB.PSRV (0x98, Local0, 0x00, 0x00, 0x01))
                            Local0 = \_SB.PSRV (0xC3, Local0, 0x00, 0x00, 0x03)
                        If ((\_SB.PSRV (0x97, 0x05000000, 0x01, 0x5000, 0x03) != 0x01))
                        If ((\_SB.PSRV (0x97, 0x05000000, 0x01, 0x5000, 0x03) == 0x01))
                        Local0 = \_SB.PSRV (0x97, 0x06000000, 0x01, 0x6000, 0x01)
PSRV (0x97, 0x06000000, 0x01, 0x6000, 0x01)       // Mouse status
                                Local3 = \_SB.PSRV (0x97, 0x03000000, 0x01, 0x3000, 0x03)
                        Local0 = \_SB.PSRV (0x97, 0x03000000, One, 0x3000, 0x03)
                            \_SB.PSRV (0x97, 0x03000000, One, 0x3100, Zero)
            If (\_SB.PSRV (0xB9, 0x22, 0x00, 0x00, 0x01))
                NSTE = \_SB.PSRV (0xB9, 0x07, 0x00, 0x00, 0x03)
            PSRV (0xB7, ((DSTA << 0x10) | 0x04), Zero, Zero, Zero)
            If (PSRV (0xB7, 0x06, Zero, Zero, One))
            ElseIf (PSRV (0xB7, 0x05, Zero, Zero, One))
                If (PSRV (0xB7, ((0x02 << 0x10) | 0x07), Zero, Zero,
                PSRV (0xB7, 0x02, Zero, Zero, Zero)
            ElseIf (PSRV (0xB7, 0x06, Zero, Zero, One))
            PSRV (0xB7, Zero, Zero, Zero, Zero)
            PSRV (0xB7, One, Zero, Zero, Zero)
            If (PSRV (0xB7, 0x0A, Zero, Zero, One))
                If (PSRV (0xB7, 0x03, Zero, Zero, One))
            ASTA = PSRV (0xB7, 0x08, Zero, Zero, One)
            Local0 = \_SB.PSRV (0xDB, Zero, Zero, Zero, One)
                PSRV (0xB7, ((ASTA << 0x10) | 0x09), Zero, Zero, Zero)
                    \_SB.PSRV (0xB7, 0x02, Zero, Zero, Zero)
            Local1 = PSRV (0xB7, 0x08, Zero, Zero, One)
            \_SB.PSRV (0x92, 0x02, 0x00, 0x00, 0x00)
            \_SB.PSRV (0x90, 0x00, 0x01, 0x03, 0x00)
            \_SB.PSRV (0x91, 0x10, 0x01, 0x01, 0x00)
            \_SB.PSRV (0x91, 0x40, 0x01, 0x01, 0x00)
            \_SB.PSRV (0x90, 0x00, 0x01, 0x04, 0x00)
            \_SB.PSRV (0x90, 0x00, 0x01, 0x05, 0x00)
                    \_SB.PSRV (0xC9, 0x04, 0x00, 0x00, 0x00)
                If (\_SB.PSRV (0xDC, 0x00, 0x00, 0x00, 0x01))
                \_SB.PSRV (0xDA, ((Local0 << 0x10) | 0x02), Zero, Zero, Zero)
                    Local0 = \_SB.PSRV (0xDA, 0x01, Zero, Zero, One)
                Local0 = \_SB.PSRV (0xDA, 0x03, Zero, Zero, One)



Dumping EC contents
===================

Determine the EC cmd/status & data port:
> cat /proc/ioports | grep EC
0062-0062 : EC data
0066-0066 : EC cmd

Dump contents of the first EC, do:
# od -A x -t x1 /sys/kernel/debug/ec/ec0/io

ECO on
0000000 08 40 00 00 00 04 88 13 23 a0 23 a0 23 a0 23 a0
0000020 23 a0 03 03 00 00 00 00 00 00 00 00 00 00 00 00
0000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
0000220 00 00 00 00 00 00 00 00 00 00 00 80 00 80 80 00
0000240 00 00 00 00 80 80 00 00 a7 26 86 a7 80 80 80 32
0000260 80 80 80 80 80 00 80 80 04 00 20 20 00 00 00 00
0000300 13 98 01 07 6c 6c 6c 81 2b 00 13 98 00 07 6c 6c
0000320 6c 9f 29 00 00 00 00 00 00 00 00 9f 00 00 00 00
0000340 00 00 00 00 00 9f 00 00 00 00 00 00 00 00 00 00
0000360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0000400

ECO off

